'use client'
import shopCategoryData from '@/components/shopData';
import React, { createContext, useContext, useState } from 'react';
import { pricingData } from '@/components/data';

const CartContext = createContext();

// Create a provider component
export const CartProvider = ({ children }) => {
    const [productStates, setProductStates] = useState({ cart: {}, isLoading: {} });
    const [currentQuantity, setCurrentQuantity] = useState(1);
    const [isItemDeleted, setIsItemDeleted] = useState(false)
    const [deletedItemTitle, setDeletedItemTitle] = useState("")
    const [deletedItem, setDeletedItem] = useState(null);
    const [updatedQuantities, setUpdatedQuantities] = useState({});

 
    const findSelectedItem = (categoryId, id) => {
      const categoryShopData = shopCategoryData.find((category) => category.category === categoryId);
      const categoryPricingData = pricingData.find((category) => category.category === categoryId);
  
      if (categoryShopData) {
        const categoryArrayName = `${categoryId.toLowerCase()}Products`;
          return categoryShopData[categoryArrayName]?.find((product) => product.product_ID === id);
      }
    
      return null;
    };

    const handleCart = (id, categoryId) => {
      setProductStates((prevStates) => {
        const isLoading = { ...prevStates.isLoading, [id]: true };
        setTimeout(() => {
          setProductStates((prevStates) => {
            const selectedItem = findSelectedItem(categoryId, id);
            if (selectedItem) {
              const cartItem = {
                product_ID: selectedItem.product_ID,
                title: selectedItem.title,
                price: selectedItem.price,
                quantity: 1,
                category: categoryId,
              };
              const cart = { ...prevStates.cart, [id]: cartItem };
              const isLoading = { ...prevStates.isLoading, [id]: false };
              return { cart, isLoading };
            }
  
            console.error('Selected item not found');
            return prevStates;
          });
        }, 2000);
  
        return { ...prevStates, isLoading };
      });
    };
  
    const isLoading = (productId) => productStates.isLoading?.[productId] || false;
    const cart = (productId) => productStates.cart?.[productId] || false;
    const cartItems = Object.values(productStates.cart);

    const handleQuantity = (id, e) => {
      const updatedCart = {
        ...productStates.cart,
        [id]: {
          ...productStates.cart[id],
          quantity: e.target.value,
        },
      };
    
      setProductStates((prevStates) => ({
        ...prevStates,
        cart: updatedCart,
      }));
    };


    const handleDelete = (id) => {
      setProductStates((prevStates) => {
        const { [id]: deletedItem, ...updatedCart } = prevStates.cart;
        setDeletedItemTitle(deletedItem.title);
        setDeletedItem(deletedItem);
        return {
          ...prevStates,
          cart: updatedCart,
        };
      });
      setIsItemDeleted(true);
    };
    

    const handleUndoDelete = () => {
      if (deletedItem) {
        setProductStates((prevStates) => ({
          ...prevStates,
          cart: { ...prevStates.cart, [deletedItem.product_ID]: deletedItem },
        }));
        setIsItemDeleted(false);
        setDeletedItem(null);
      }
    };
    
    const handleQuantityChange = (id, e) => {
      const value = parseInt(e.target.value, 10) || 1;
    
      setUpdatedQuantities((prevQuantities) => ({
        ...prevQuantities,
        [id]: value,
      }));
    };
    
  
    const handleUpdateCart = (updatedQuantities) => {
    
      const updatedCart = {};
      Object.keys(productStates.cart).forEach((id) => {
        const newQuantity = updatedQuantities[id] !== undefined ? updatedQuantities[id] : productStates.cart[id].quantity;
  
        updatedCart[id] = {
          ...productStates.cart[id],
          quantity: newQuantity,
        };
      });
  
      setProductStates((prevStates) => ({
        ...prevStates,
        cart: updatedCart,
      }));
    };
  
  const contextValue = {
    handleCart,
    isLoading,
    cart,
    cartItems,
    handleDelete,
    isItemDeleted,
    deletedItemTitle,
    handleUndoDelete,
    handleQuantityChange,
    currentQuantity,
    handleUpdateCart
   
  };

  return <CartContext.Provider value={contextValue}>{children}</CartContext.Provider>;
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};
